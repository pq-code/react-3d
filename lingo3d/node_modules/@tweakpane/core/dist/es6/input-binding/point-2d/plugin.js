import { CompositeConstraint, findConstraint, } from '../../common/constraint/composite';
import { RangeConstraint } from '../../common/constraint/range';
import { StepConstraint } from '../../common/constraint/step';
import { createNumberFormatter, parseNumber, } from '../../common/converter/number';
import { ValueMap } from '../../common/model/value-map';
import { ParamsParsers, parseParams } from '../../common/params-parsers';
import { TpError } from '../../common/tp-error';
import { getBaseStep, getSuitableDecimalDigits, getSuitableDraggingScale, parsePickerLayout, parsePointDimensionParams, } from '../../common/util';
import { isEmpty } from '../../misc/type-util';
import { PointNdConstraint } from '../common/constraint/point-nd';
import { Point2dController } from './controller/point-2d';
import { point2dFromUnknown, writePoint2d } from './converter/point-2d';
import { Point2d, Point2dAssembly } from './model/point-2d';
function createDimensionConstraint(params) {
    if (!params) {
        return undefined;
    }
    const constraints = [];
    if (!isEmpty(params.step)) {
        constraints.push(new StepConstraint(params.step));
    }
    if (!isEmpty(params.max) || !isEmpty(params.min)) {
        constraints.push(new RangeConstraint({
            max: params.max,
            min: params.min,
        }));
    }
    return new CompositeConstraint(constraints);
}
function createConstraint(params) {
    return new PointNdConstraint({
        assembly: Point2dAssembly,
        components: [
            createDimensionConstraint('x' in params ? params.x : undefined),
            createDimensionConstraint('y' in params ? params.y : undefined),
        ],
    });
}
function getSuitableMaxDimensionValue(constraint, rawValue) {
    const rc = constraint && findConstraint(constraint, RangeConstraint);
    if (rc) {
        return Math.max(Math.abs(rc.minValue || 0), Math.abs(rc.maxValue || 0));
    }
    const step = getBaseStep(constraint);
    return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
/**
 * @hidden
 */
export function getSuitableMaxValue(initialValue, constraint) {
    const xc = constraint instanceof PointNdConstraint
        ? constraint.components[0]
        : undefined;
    const yc = constraint instanceof PointNdConstraint
        ? constraint.components[1]
        : undefined;
    const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
    const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
    return Math.max(xr, yr);
}
function createAxis(initialValue, constraint) {
    return {
        baseStep: getBaseStep(constraint),
        constraint: constraint,
        textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
        }),
    };
}
function shouldInvertY(params) {
    if (!('y' in params)) {
        return false;
    }
    const yParams = params.y;
    if (!yParams) {
        return false;
    }
    return 'inverted' in yParams ? !!yParams.inverted : false;
}
/**
 * @hidden
 */
export const Point2dInputPlugin = {
    id: 'input-point2d',
    type: 'input',
    accept: (value, params) => {
        if (!Point2d.isObject(value)) {
            return null;
        }
        const p = ParamsParsers;
        const result = parseParams(params, {
            expanded: p.optional.boolean,
            picker: p.optional.custom(parsePickerLayout),
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.object({
                inverted: p.optional.boolean,
                max: p.optional.number,
                min: p.optional.number,
                step: p.optional.number,
            }),
        });
        return result
            ? {
                initialValue: value,
                params: result,
            }
            : null;
    },
    binding: {
        reader: (_args) => point2dFromUnknown,
        constraint: (args) => createConstraint(args.params),
        equals: Point2d.equals,
        writer: (_args) => writePoint2d,
    },
    controller: (args) => {
        const doc = args.document;
        const value = args.value;
        const c = args.constraint;
        if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
        }
        const expanded = 'expanded' in args.params ? args.params.expanded : undefined;
        const picker = 'picker' in args.params ? args.params.picker : undefined;
        return new Point2dController(doc, {
            axes: [
                createAxis(value.rawValue.x, c.components[0]),
                createAxis(value.rawValue.y, c.components[1]),
            ],
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            invertsY: shouldInvertY(args.params),
            maxValue: getSuitableMaxValue(value.rawValue, c),
            parser: parseNumber,
            pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
            value: value,
            viewProps: args.viewProps,
        });
    },
};
