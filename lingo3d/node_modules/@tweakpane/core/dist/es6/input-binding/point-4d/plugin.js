import { CompositeConstraint } from '../../common/constraint/composite';
import { RangeConstraint } from '../../common/constraint/range';
import { StepConstraint } from '../../common/constraint/step';
import { createNumberFormatter, parseNumber, } from '../../common/converter/number';
import { ValueMap } from '../../common/model/value-map';
import { ParamsParsers, parseParams } from '../../common/params-parsers';
import { TpError } from '../../common/tp-error';
import { getBaseStep, getSuitableDecimalDigits, getSuitableDraggingScale, parsePointDimensionParams, } from '../../common/util';
import { isEmpty } from '../../misc/type-util';
import { PointNdConstraint } from '../common/constraint/point-nd';
import { PointNdTextController } from '../common/controller/point-nd-text';
import { point4dFromUnknown, writePoint4d } from './converter/point-4d';
import { Point4d, Point4dAssembly } from './model/point-4d';
function createDimensionConstraint(params) {
    if (!params) {
        return undefined;
    }
    const constraints = [];
    if (!isEmpty(params.step)) {
        constraints.push(new StepConstraint(params.step));
    }
    if (!isEmpty(params.max) || !isEmpty(params.min)) {
        constraints.push(new RangeConstraint({
            max: params.max,
            min: params.min,
        }));
    }
    return new CompositeConstraint(constraints);
}
function createConstraint(params) {
    return new PointNdConstraint({
        assembly: Point4dAssembly,
        components: [
            createDimensionConstraint('x' in params ? params.x : undefined),
            createDimensionConstraint('y' in params ? params.y : undefined),
            createDimensionConstraint('z' in params ? params.z : undefined),
            createDimensionConstraint('w' in params ? params.w : undefined),
        ],
    });
}
function createAxis(initialValue, constraint) {
    return {
        baseStep: getBaseStep(constraint),
        constraint: constraint,
        textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue)),
        }),
    };
}
/**
 * @hidden
 */
export const Point4dInputPlugin = {
    id: 'input-point4d',
    type: 'input',
    accept: (value, params) => {
        if (!Point4d.isObject(value)) {
            return null;
        }
        const p = ParamsParsers;
        const result = parseParams(params, {
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.custom(parsePointDimensionParams),
            z: p.optional.custom(parsePointDimensionParams),
            w: p.optional.custom(parsePointDimensionParams),
        });
        return result
            ? {
                initialValue: value,
                params: result,
            }
            : null;
    },
    binding: {
        reader: (_args) => point4dFromUnknown,
        constraint: (args) => createConstraint(args.params),
        equals: Point4d.equals,
        writer: (_args) => writePoint4d,
    },
    controller: (args) => {
        const value = args.value;
        const c = args.constraint;
        if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
        }
        return new PointNdTextController(args.document, {
            assembly: Point4dAssembly,
            axes: value.rawValue
                .getComponents()
                .map((comp, index) => createAxis(comp, c.components[index])),
            parser: parseNumber,
            value: value,
            viewProps: args.viewProps,
        });
    },
};
