import Events from "@lincode/events";
import { container } from "../engine/renderLoop/renderSetup";
import { Group } from "three";
import { mouseDefaults, mouseSchema } from "../interface/IMouse";
import EventLoopItem from "./core/EventLoopItem";
import { throttle } from "@lincode/utils";
import { loop } from "../engine/eventLoop";
import { getSelectionBlockMouse } from "../states/useSelectionBlockMouse";
import { appendableRoot } from "./core/Appendable";
import clientToWorld from "../display/utils/clientToWorld";
import store from "@lincode/reactivity";
import { getEditorActive } from "../states/useEditorActive";
export const mouseEvents = new Events();
let downTime = 0;
let downX = 0;
let downY = 0;
mouseEvents.on("down", e => {
    downTime = Date.now();
    downX = e.clientX;
    downY = e.clientY;
});
mouseEvents.on("up", e => {
    const upTime = Date.now();
    const deltaTime = upTime - downTime;
    const deltaX = Math.abs(e.clientX - downX);
    const deltaY = Math.abs(e.clientY - downY);
    downTime = upTime;
    downX = e.clientX;
    downY = e.clientY;
    if (deltaTime < 300 && deltaX < 5 && deltaY < 5)
        mouseEvents.emit("click", e);
});
const computeMouse = throttle(clientToWorld, 0, "leading");
container.addEventListener("pointermove", ev => {
    mouseEvents.emit("move", computeMouse(ev));
});
let down = false;
container.addEventListener("pointerdown", ev => {
    down = true;
    const payload = computeMouse(ev);
    mouseEvents.emit("down", payload);
    mouseEvents.emit("move", payload);
});
const handleUp = (ev) => {
    down && mouseEvents.emit("up", computeMouse(ev));
    down = false;
};
container.addEventListener("pointerup", handleUp);
container.addEventListener("pointercancel", handleUp);
container.addEventListener("pointerleave", handleUp);
export class Mouse extends EventLoopItem {
    constructor() {
        super(new Group());
        let currentPayload = { x: 0, y: 0, z: 0, clientX: 0, clientY: 0, xNorm: 0, yNorm: 0 };
        const [setDown, getDown] = store(false);
        this.createEffect(() => {
            const cb = this.onMousePress;
            if (!getDown() || !cb)
                return;
            const handle = loop(() => cb(currentPayload));
            return () => {
                handle.cancel();
            };
        }, [getDown]);
        this.createEffect(() => {
            if (getEditorActive() && getSelectionBlockMouse())
                return;
            const handle0 = mouseEvents.on("move", e => {
                var _a;
                (_a = this.onMouseMove) === null || _a === void 0 ? void 0 : _a.call(this, e);
                currentPayload = e;
            });
            const handle1 = mouseEvents.on("click", e => {
                var _a;
                (_a = this.onClick) === null || _a === void 0 ? void 0 : _a.call(this, e);
                currentPayload = e;
            });
            const handle2 = mouseEvents.on("down", e => {
                var _a;
                (_a = this.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(this, e);
                currentPayload = e;
                setDown(true);
            });
            const handle3 = mouseEvents.on("up", e => {
                var _a;
                (_a = this.onMouseUp) === null || _a === void 0 ? void 0 : _a.call(this, e);
                currentPayload = e;
                setDown(false);
            });
            return () => {
                handle0.cancel();
                handle1.cancel();
                handle2.cancel();
                handle3.cancel();
            };
        }, [getEditorActive, getSelectionBlockMouse]);
    }
}
Mouse.componentName = "mouse";
Mouse.defaults = mouseDefaults;
Mouse.schema = mouseSchema;
const mouse = new Mouse();
appendableRoot.delete(mouse);
export default mouse;
