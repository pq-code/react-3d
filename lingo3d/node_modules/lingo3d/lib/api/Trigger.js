import { Reactive } from "@lincode/reactivity";
import { Group } from "three";
import { idMap } from "../display/core/SimpleObjectManager";
import Cylinder from "../display/primitives/Cylinder";
import Sphere from "../display/primitives/Sphere";
import getActualScale from "../display/utils/getActualScale";
import getWorldPosition from "../display/utils/getWorldPosition";
import { scaleDown } from "../engine/constants";
import { timer } from "../engine/eventLoop";
import mainCamera from "../engine/mainCamera";
import scene from "../engine/scene";
import { emitSelectionTarget, onSelectionTarget } from "../events/onSelectionTarget";
import { triggerDefaults, triggerSchema } from "../interface/ITrigger";
import { getCamera } from "../states/useCamera";
import { appendableRoot } from "./core/Appendable";
import PositionedItem from "./core/PositionedItem";
const getTargets = (id) => { var _a; return [...((_a = idMap.get(id)) !== null && _a !== void 0 ? _a : [])]; };
export default class Trigger extends PositionedItem {
    constructor() {
        const group = new Group();
        super(group);
        this.refresh = new Reactive({});
        this._pad = triggerDefaults.pad;
        this._radius = triggerDefaults.radius;
        this._interval = triggerDefaults.interval;
        this._helper = triggerDefaults.helper;
        this._targetIds = triggerDefaults.targetIds;
        scene.add(group);
        let helper;
        this.createEffect(() => {
            const { _radius, _interval, _targetIds, _pad } = this;
            if (!_targetIds)
                return;
            const r = _radius * scaleDown;
            const pr = r * 0.2;
            let hitOld = false;
            const handle = timer(_interval, -1, () => {
                var _a, _b;
                const { x, y, z } = getWorldPosition(this.outerObject3d);
                const targets = typeof _targetIds === "string" ? getTargets(_targetIds) : _targetIds.map(getTargets).flat();
                let hit = false;
                for (const target of targets) {
                    const { x: tx, y: ty, z: tz } = getWorldPosition(target.object3d);
                    if (_pad) {
                        const { y: sy } = getActualScale(target);
                        hit = Math.abs(x - tx) < r && Math.abs(y - (ty - sy * 0.5)) < pr && Math.abs(z - tz) < r;
                    }
                    else
                        hit = Math.abs(x - tx) < r && Math.abs(y - ty) < r && Math.abs(z - tz) < r;
                    if (hit)
                        break;
                }
                if (hitOld !== hit)
                    if (hit) {
                        (_a = this.onEnter) === null || _a === void 0 ? void 0 : _a.call(this);
                        helper && (helper.color = "blue");
                    }
                    else {
                        (_b = this.onExit) === null || _b === void 0 ? void 0 : _b.call(this);
                        helper && (helper.color = "white");
                    }
                hitOld = hit;
            });
            return () => {
                handle.cancel();
            };
        }, [this.refresh.get]);
        this.createEffect(() => {
            const { _radius, _helper, _pad } = this;
            if (!_helper)
                return;
            if (getCamera() !== mainCamera)
                return;
            const h = helper = _pad ? new Cylinder() : new Sphere();
            appendableRoot.delete(h);
            group.add(h.outerObject3d);
            h.scale = _radius * scaleDown * 2;
            h.opacity = 0.5;
            h.height = _pad ? 10 : 100;
            const handle = onSelectionTarget(target => target === h && emitSelectionTarget(this));
            return () => {
                h.dispose();
                helper = undefined;
                handle.cancel();
            };
        }, [this.refresh.get, getCamera]);
    }
    get pad() {
        return this._pad;
    }
    set pad(val) {
        this._pad = val;
        this.refresh.set({});
    }
    get radius() {
        return this._radius;
    }
    set radius(val) {
        this._radius = val;
        this.refresh.set({});
    }
    get interval() {
        return this._interval;
    }
    set interval(val) {
        this._interval = val;
        this.refresh.set({});
    }
    get helper() {
        return this._helper;
    }
    set helper(val) {
        this._helper = val;
        this.refresh.set({});
    }
    get targetIds() {
        return this._targetIds;
    }
    set targetIds(val) {
        this._targetIds = val;
        this.refresh.set({});
    }
}
Trigger.componentName = "trigger";
Trigger.defaults = triggerDefaults;
Trigger.schema = triggerSchema;
