import { getExtensionType } from "@lincode/filetypes";
import { Cancellable } from "@lincode/promiselikes";
import { assertExhaustive, splitFileName } from "@lincode/utils";
import bytesLoaded from "../display/utils/loaders/bytesLoaded";
import { lazyLoadFBX, lazyLoadGLTF } from "../display/utils/loaders/lazyLoad";
import loadTexturePromise from "../display/utils/loaders/loadTexturePromise";
import { getLoadingCount } from "../states/useLoadingCount";
export default async (urls, total, onProgress) => {
    var _a;
    const promises = [];
    for (const url of urls) {
        const filetype = getExtensionType(url);
        if (!filetype)
            continue;
        switch (filetype) {
            case "image":
                promises.push(loadTexturePromise(url));
                break;
            case "model":
                const extension = (_a = splitFileName(url)[1]) === null || _a === void 0 ? void 0 : _a.toLowerCase();
                if (extension === "fbx")
                    promises.push((await lazyLoadFBX()).default(url, false));
                else if (extension === "gltf" || extension === "glb")
                    promises.push((await lazyLoadGLTF()).default(url, false));
                break;
            case "audio":
            case "plainText":
            case "scene":
                break;
            default:
                assertExhaustive(filetype);
        }
    }
    let totalBytes = 0;
    if (typeof total === "number")
        totalBytes = total;
    else {
        total = total.toLowerCase();
        if (total.endsWith("kb"))
            totalBytes = parseFloat(total) * 1024 * 1024;
        else if (total.endsWith("mb"))
            totalBytes = parseFloat(total) * 1024 * 1024 * 1024;
        else if (total.endsWith("gb"))
            totalBytes = parseFloat(total) * 1024 * 1024 * 1024 * 1024;
        else
            throw new Error("invalid preload total value: " + total);
    }
    const interval = setInterval(() => {
        onProgress === null || onProgress === void 0 ? void 0 : onProgress(totalBytes <= 0 ? 0 : Math.min(bytesLoaded[0] / totalBytes * 100, 99));
    }, 100);
    await Promise.all(promises);
    clearInterval(interval);
    await new Promise(resolve => {
        const handle = new Cancellable();
        handle.watch(getLoadingCount(count => {
            if (count > 0)
                return;
            handle.cancel();
            resolve();
        }));
    });
    onProgress === null || onProgress === void 0 ? void 0 : onProgress(100);
};
