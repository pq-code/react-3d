import { Raycaster } from "three";
import { mouseEvents } from "../../../api/mouse";
import { createEffect, createNestedEffect, createRef } from "@lincode/reactivity";
import { getSelection } from "../../../states/useSelection";
import { getSelectionTarget, setSelectionTarget } from "../../../states/useSelectionTarget";
import { getCamera } from "../../../states/useCamera";
import scene from "../../../engine/scene";
import { getMultipleSelection } from "../../../states/useMultipleSelection";
import { getMultipleSelectionTargets, pullMultipleSelectionTargets, pushMultipleSelectionTargets, resetMultipleSelectionTargets } from "../../../states/useMultipleSelectionTargets";
import { emitSelectionTarget, onSelectionTarget } from "../../../events/onSelectionTarget";
import { scaleUp } from "../../../engine/constants";
import { Cancellable } from "@lincode/promiselikes";
import { vec2Point } from "../../utils/vec2Point";
import mainCamera from "../../../engine/mainCamera";
import { getTransformControlsDragging } from "../../../states/useTransformControlsDragging";
import { debounce } from "@lincode/utils";
import { onSceneChange } from "../../../events/onSceneChange";
import { getSelectionBlockMouse } from "../../../states/useSelectionBlockMouse";
const raycaster = new Raycaster();
export const selectionCandidates = new Set();
const getSelectionCandidates = debounce(() => {
    selectionCandidates.clear();
    scene.traverse(c => {
        var _a;
        const { manager } = c.userData;
        manager && selectionCandidates.add((_a = manager.object3d) !== null && _a !== void 0 ? _a : c);
    });
}, 0, "trailing");
const raycast = (x, y, candidates) => {
    raycaster.setFromCamera({ x, y }, getCamera());
    return raycaster.intersectObjects([...candidates])[0];
};
const pickable = (name, candidates, then) => (mouseEvents.on(name, e => {
    const result = raycast(e.xNorm, e.yNorm, candidates);
    if (!result)
        return;
    const point = vec2Point(result.point);
    const distance = result.distance * scaleUp;
    then(result.object.userData.manager, { ...e, point, distance });
}));
export const clickSet = new Set();
export const mouseDownSet = new Set();
export const mouseUpSet = new Set();
export const mouseOverSet = new Set();
export const mouseOutSet = new Set();
export const mouseMoveSet = new Set();
const enableMouseEvents = () => {
    const handle = new Cancellable();
    handle.watch(pickable("click", clickSet, (obj, e) => { var _a; return (_a = obj.onClick) === null || _a === void 0 ? void 0 : _a.call(obj, e); }));
    handle.watch(pickable("down", mouseDownSet, (obj, e) => { var _a; return (_a = obj.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(obj, e); }));
    handle.watch(pickable("up", mouseUpSet, (obj, e) => { var _a; return (_a = obj.onMouseUp) === null || _a === void 0 ? void 0 : _a.call(obj, e); }));
    let moveSet = new Set();
    let moveSetOld = new Set();
    handle.watch(pickable("move", mouseOverSet, (obj, e) => {
        moveSet.add(obj);
        obj.outerObject3d.userData.eMove = e;
    }));
    handle.watch(pickable("move", mouseOutSet, (obj, e) => {
        moveSet.add(obj);
        obj.outerObject3d.userData.eMove = e;
    }));
    handle.watch(pickable("move", mouseMoveSet, (obj, e) => {
        moveSet.add(obj);
        obj.outerObject3d.userData.eMove = e;
    }));
    handle.watch(mouseEvents.on("move", () => {
        var _a, _b, _c;
        for (const obj of moveSet) {
            if (!moveSetOld.has(obj))
                (_a = obj.onMouseOver) === null || _a === void 0 ? void 0 : _a.call(obj, obj.outerObject3d.userData.eMove);
            (_b = obj.onMouseMove) === null || _b === void 0 ? void 0 : _b.call(obj, obj.outerObject3d.userData.eMove);
        }
        for (const obj of moveSetOld)
            if (!moveSet.has(obj))
                (_c = obj.onMouseOut) === null || _c === void 0 ? void 0 : _c.call(obj, obj.outerObject3d.userData.eMove);
        moveSetOld = moveSet;
        moveSet = new Set();
    }));
    return handle;
};
createEffect(() => {
    const selection = getSelection();
    const multipleSelection = getMultipleSelection();
    const firstMultipleSelection = createRef(true);
    createNestedEffect(() => {
        !multipleSelection && (firstMultipleSelection.current = true);
    }, [multipleSelection]);
    if (selection && !getTransformControlsDragging() && getCamera() === mainCamera) {
        const handle = new Cancellable();
        getSelectionCandidates();
        handle.watch(onSceneChange(getSelectionCandidates));
        handle.watch(mouseEvents.on("click", () => {
            emitSelectionTarget(undefined);
        }));
        handle.watch(pickable("click", selectionCandidates, target => {
            emitSelectionTarget(target);
        }));
        handle.watch(onSelectionTarget(target => {
            if (multipleSelection) {
                if (!target)
                    return;
                if (firstMultipleSelection.current) {
                    const currentTarget = getSelectionTarget();
                    currentTarget && pushMultipleSelectionTargets(currentTarget);
                }
                firstMultipleSelection.current = false;
                if (getMultipleSelectionTargets().includes(target))
                    pullMultipleSelectionTargets(target);
                else
                    pushMultipleSelectionTargets(target);
                return;
            }
            resetMultipleSelectionTargets();
            setSelectionTarget(target === getSelectionTarget() ? undefined : target);
        }));
        if (!multipleSelection && !getSelectionBlockMouse())
            handle.watch(enableMouseEvents());
        return () => {
            handle.cancel();
        };
    }
    if (selection)
        return;
    resetMultipleSelectionTargets();
    setSelectionTarget(undefined);
    const handle = enableMouseEvents();
    return () => {
        handle.cancel();
    };
}, [getSelection, getSelectionBlockMouse, getTransformControlsDragging, getCamera, getMultipleSelection]);
