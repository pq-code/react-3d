import { Disposable } from "@lincode/promiselikes";
import { AnimationMixer, AnimationClip, NumberKeyframeTrack, LoopRepeat, LoopOnce } from "three";
import { forceGet } from "@lincode/utils";
import clockDelta from "../../utils/clockDelta";
import { loop } from "../../../engine/eventLoop";
const targetMixerMap = new WeakMap();
const mixerActionMap = new WeakMap();
const mixerHandleMap = new WeakMap();
export default class AnimationManager extends Disposable {
    constructor(nameOrClip, target) {
        super();
        this.mixer = forceGet(targetMixerMap, target, () => new AnimationMixer(target));
        if (typeof nameOrClip === "string")
            this.name = nameOrClip;
        else {
            this.name = nameOrClip.name;
            this.loadClip(nameOrClip);
        }
    }
    retarget(target) {
        const newClip = this.clip.clone();
        const targetName = target.name + ".";
        newClip.tracks = newClip.tracks.filter(track => track.name.startsWith(targetName));
        return new AnimationManager(newClip, target);
    }
    dispose() {
        super.dispose();
        this.stop();
        return this;
    }
    get duration() {
        var _a, _b;
        return (_b = (_a = this.clip) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : 0;
    }
    loadClip(clip) {
        this.clip = clip;
        this.action = this.mixer.clipAction(clip);
    }
    setTracks(data) {
        const tracks = Object.entries(data).map(([property, frames]) => new NumberKeyframeTrack("." + property, Object.keys(frames).map(t => Number(t)), Object.values(frames)));
        this.clip && (this.mixer.uncacheClip(this.clip));
        this.loadClip(new AnimationClip(this.name, -1, tracks));
    }
    play({ crossFade = 0.25, repeat = true, onFinish } = {}) {
        var _a, _b;
        const [prevAction, prevRepeat] = (_a = mixerActionMap.get(this.mixer)) !== null && _a !== void 0 ? _a : [];
        if ((prevAction === null || prevAction === void 0 ? void 0 : prevAction.isRunning()) && this.action === prevAction) {
            repeat !== prevRepeat && prevAction.setLoop(repeat ? LoopRepeat : LoopOnce, Infinity);
            return;
        }
        (_b = mixerHandleMap.get(this.mixer)) === null || _b === void 0 ? void 0 : _b.cancel();
        const handle = this.watch(loop(() => this.mixer.update(clockDelta[0])));
        mixerHandleMap.set(this.mixer, handle);
        const { action } = this;
        if (!action)
            return;
        if (prevAction && crossFade) {
            action.time = 0;
            action.enabled = true;
            action.crossFadeFrom(prevAction, crossFade, true);
        }
        else
            this.mixer.stopAllAction();
        mixerActionMap.set(this.mixer, [action, repeat]);
        action.setLoop(repeat ? LoopRepeat : LoopOnce, Infinity);
        action.clampWhenFinished = true;
        const handleFinish = () => onFinish === null || onFinish === void 0 ? void 0 : onFinish();
        this.mixer.addEventListener("finished", handleFinish);
        handle.then(() => this.mixer.removeEventListener("finished", handleFinish));
        action.paused && action.stop();
        action.play();
    }
    stop() {
        var _a;
        this.action && (this.action.paused = true);
        (_a = mixerHandleMap.get(this.mixer)) === null || _a === void 0 ? void 0 : _a.cancel();
    }
    getPaused() {
        var _a;
        return (_a = this.action) === null || _a === void 0 ? void 0 : _a.paused;
    }
    setPaused(val) {
        this.action && (this.action.paused = val);
    }
    update(seconds) {
        this.mixer.time = 0;
        this.action && (this.action.time = 0);
        this.mixer.update(seconds);
    }
}
