import { Group } from "three";
import ObjectManager from "../ObjectManager";
import CameraMixin from "../mixins/CameraMixin";
import { applyMixins, debounce } from "@lincode/utils";
import { scaleUp, scaleDown } from "../../../engine/constants";
import { ray, vector3_, vector3, euler } from "../../utils/reusables";
import pillShape from "../SimpleObjectManager/PhysicsItem/cannon/shapes/pillShape";
import { deg2Rad, rad2Deg } from "@lincode/math";
import { MIN_POLAR_ANGLE, MAX_POLAR_ANGLE } from "../../../globals";
import { Reactive } from "@lincode/reactivity";
const PI_2 = Math.PI * 0.5;
class CameraBase extends ObjectManager {
    constructor(camera) {
        super(new Group());
        this._physicsShape = pillShape;
        this.updatePolarAngle = debounce(() => this.gyrate(0, 0), 0, "trailing");
        this._minPolarAngle = MIN_POLAR_ANGLE * deg2Rad;
        this._maxPolarAngle = MAX_POLAR_ANGLE * deg2Rad;
        this.mouseControlState = new Reactive(false);
        this.camera = camera;
        this.object3d.add(camera);
        this.initCamera();
    }
    getRay() {
        return ray.set(this.camera.getWorldPosition(vector3_), this.camera.getWorldDirection(vector3));
    }
    append(object) {
        this._append(object);
        this.camera.add(object.outerObject3d);
    }
    attach(object) {
        this._append(object);
        this.camera.attach(object.outerObject3d);
    }
    get width() {
        return this.object3d.scale.x * scaleUp;
    }
    set width(val) {
        const num = val * scaleDown;
        this.object3d.scale.x = num;
        this.camera.scale.x = 1 / num;
    }
    get height() {
        return this.object3d.scale.y * scaleUp;
    }
    set height(val) {
        const num = val * scaleDown;
        this.object3d.scale.y = num;
        this.camera.scale.y = 1 / num;
    }
    get depth() {
        return this.object3d.scale.z * scaleUp;
    }
    set depth(val) {
        const num = val * scaleDown;
        this.object3d.scale.z = num;
        this.camera.scale.z = 1 / num;
    }
    lookAt(target) {
        super.lookAt(target);
        this.rotationY += 180;
    }
    _gyrate(movementX, movementY, inner) {
        const manager = inner ? this.object3d : this.outerObject3d;
        euler.setFromQuaternion(manager.quaternion);
        euler.y -= movementX * 0.002;
        euler.x -= movementY * 0.002;
        euler.x = Math.max(PI_2 - this._maxPolarAngle, Math.min(PI_2 - this._minPolarAngle, euler.x));
        manager.setRotationFromEuler(euler);
        !inner && this.physicsRotate();
    }
    gyrate(movementX, movementY) {
        if (this.mouseControlMode === "orbit")
            this._gyrate(movementX, movementY);
        else {
            this._gyrate(movementX, 0);
            this._gyrate(0, movementY, true);
        }
    }
    get minPolarAngle() {
        return this._minPolarAngle * rad2Deg;
    }
    set minPolarAngle(val) {
        this._minPolarAngle = val * deg2Rad;
        this.updatePolarAngle();
    }
    get maxPolarAngle() {
        return this._maxPolarAngle * rad2Deg;
    }
    set maxPolarAngle(val) {
        this._maxPolarAngle = val * deg2Rad;
        this.updatePolarAngle();
    }
    get mouseControl() {
        return this.mouseControlState.get();
    }
    set mouseControl(val) {
        this.mouseControlState.set(val);
        if (!val || this.mouseControlInit)
            return;
        this.mouseControlInit = true;
        import("./enableMouseControl").then(module => module.default.call(this));
    }
    getCenter() {
        return this.getWorldPosition();
    }
}
applyMixins(CameraBase, [CameraMixin]);
export default CameraBase;
