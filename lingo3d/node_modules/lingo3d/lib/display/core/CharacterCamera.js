import { deg2Rad } from "@lincode/math";
import { Reactive } from "@lincode/reactivity";
import { Quaternion } from "three";
import { loop } from "../../engine/eventLoop";
import scene from "../../engine/scene";
import { onSceneChange } from "../../events/onSceneChange";
import { characterCameraDefaults, characterCameraSchema } from "../../interface/ICharacterCamera";
import { getSelectionTarget } from "../../states/useSelectionTarget";
import { getTransformControlsDragging } from "../../states/useTransformControlsDragging";
import { getTransformControlsMode } from "../../states/useTransformControlsMode";
import Camera from "../cameras/Camera";
import { euler, quaternion, quaternion_ } from "../utils/reusables";
export default class CharacterCamera extends Camera {
    constructor() {
        super();
        this.lockTargetRotation = true;
        this.targetState = new Reactive(undefined);
        const cam = this.camera;
        scene.attach(cam);
        this.then(() => scene.remove(cam));
        this.createEffect(() => {
            const target = this.targetState.get();
            if (!target)
                return;
            if ("frustumCulled" in target)
                target.frustumCulled = false;
            const handle = onSceneChange(() => target.parent !== this && this.targetState.set(undefined));
            return () => {
                handle.cancel();
            };
        }, [this.targetState.get]);
        const followTarget = (target) => {
            euler.setFromQuaternion(target.outerObject3d.quaternion);
            euler.y += Math.PI;
            this.outerObject3d.setRotationFromEuler(euler);
            this.updatePolarAngle();
        };
        let transformControlRotating = false;
        this.createEffect(() => {
            const target = this.targetState.get();
            if (!target)
                return;
            followTarget(target);
            let targetRotated = false;
            //@ts-ignore
            target.onRotationY = () => targetRotated = true;
            const handle = loop(() => {
                this.outerObject3d.position.copy(target.outerObject3d.position);
                if (!this.lockTargetRotation)
                    return;
                if (this.lockTargetRotation === "follow" || transformControlRotating || targetRotated) {
                    targetRotated = false;
                    followTarget(target);
                    return;
                }
                euler.setFromQuaternion(this.outerObject3d.quaternion);
                euler.x = 0;
                euler.z = 0;
                euler.y += Math.PI;
                target.outerObject3d.setRotationFromEuler(euler);
            });
            return () => {
                handle.cancel();
                //@ts-ignore
                target.onRotationY = undefined;
            };
        }, [this.targetState.get]);
        this.createEffect(() => {
            const target = this.targetState.get();
            const selectionTarget = getSelectionTarget();
            const dragging = getTransformControlsDragging();
            const mode = getTransformControlsMode();
            const rotating = target && target === selectionTarget && dragging && mode === "rotate";
            if (!rotating)
                return;
            transformControlRotating = true;
            return () => {
                transformControlRotating = false;
            };
        }, [this.targetState.get, getSelectionTarget, getTransformControlsDragging, getTransformControlsMode]);
    }
    append(object) {
        var _a;
        if (this.targetState.get()) {
            super.append(object);
            return;
        }
        this._append(object);
        (_a = this.outerObject3d.parent) === null || _a === void 0 ? void 0 : _a.add(object.outerObject3d);
        this.targetState.set(object);
    }
    attach(object) {
        var _a;
        if (this.targetState.get()) {
            super.attach(object);
            return;
        }
        this._append(object);
        (_a = this.outerObject3d.parent) === null || _a === void 0 ? void 0 : _a.attach(object.outerObject3d);
        this.targetState.set(object);
    }
    get gyroControl() {
        return !!this._gyroControl;
    }
    set gyroControl(val) {
        var _a;
        if (this._gyroControl === val)
            return;
        this._gyroControl;
        (_a = this.gyroControlHandle) === null || _a === void 0 ? void 0 : _a.cancel();
        const deviceEuler = euler;
        const deviceQuaternion = quaternion;
        const screenTransform = quaternion_;
        const worldTransform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
        const quat = this.object3d.getWorldQuaternion(quaternion).clone();
        const orient = 0;
        const cb = (e) => {
            var _a, _b, _c;
            this.object3d.quaternion.copy(quat);
            deviceEuler.set(((_a = e.beta) !== null && _a !== void 0 ? _a : 0) * deg2Rad, ((_b = e.alpha) !== null && _b !== void 0 ? _b : 0) * deg2Rad, -((_c = e.gamma) !== null && _c !== void 0 ? _c : 0) * deg2Rad, "YXZ");
            this.object3d.quaternion.multiply(deviceQuaternion.setFromEuler(deviceEuler));
            const minusHalfAngle = -orient * 0.5;
            screenTransform.set(0, Math.sin(minusHalfAngle), 0, Math.cos(minusHalfAngle));
            this.object3d.quaternion.multiply(screenTransform);
            this.object3d.quaternion.multiply(worldTransform);
        };
        window.addEventListener("deviceorientation", cb);
        this.gyroControlHandle = this.cancellable(() => window.removeEventListener("deviceorientation", cb));
    }
}
CharacterCamera.defaults = characterCameraDefaults;
CharacterCamera.schema = characterCameraSchema;
