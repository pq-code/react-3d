import { SpriteMaterial, Sprite, Color } from "three";
import scene from "../../engine/scene";
import { scaleDown } from "../../engine/constants";
import { addBloom, deleteBloom } from "../../engine/renderLoop/effectComposer/selectiveBloomPass/renderSelectiveBloom";
import { loop } from "../../engine/eventLoop";
const disposed = [];
const colorObj = new Color();
const colorEndObj = new Color();
let colorOld = "";
let colorEndOld = "";
export const createParticle = () => {
    var _a;
    return (_a = disposed.pop()) !== null && _a !== void 0 ? _a : new Particle();
};
const activeParticles = new Set();
loop(() => {
    for (const particle of activeParticles)
        particle.update();
});
export default class Particle {
    constructor() {
        this.material = new SpriteMaterial();
        this.sprite = new Sprite(this.material);
    }
    init(texture, bloom, size, sizeEnd = size, opacity, opacityEnd = opacity, color, colorEnd = color, worldX, worldY, worldZ, accelX, accelY, accelZ, speedX, speedY, speedZ, lifeTime) {
        activeParticles.add(this);
        this.material.map = texture;
        bloom ? addBloom(this.sprite) : deleteBloom(this.sprite);
        this.accelX = accelX * scaleDown;
        this.accelY = accelY * scaleDown;
        this.accelZ = accelZ * scaleDown;
        this.speedX = speedX * scaleDown;
        this.speedY = speedY * scaleDown;
        this.speedZ = speedZ * scaleDown;
        this.lifeTime = lifeTime;
        this.startTime = Date.now();
        scene.add(this.sprite);
        this.scaleStart = this.sprite.scale.x = this.sprite.scale.y = size * scaleDown;
        this.sizeRange = (sizeEnd - size) * scaleDown;
        this.opacityStart = this.material.opacity = opacity;
        this.opacityRange = opacityEnd - opacity;
        if (color !== colorOld) {
            colorOld = color;
            colorObj.set(color);
        }
        if (colorEndOld !== colorEnd) {
            colorEndOld = colorEnd;
            colorEndObj.set(colorEnd);
        }
        this.rStart = this.material.color.r = colorObj.r;
        this.rRange = colorEndObj.r - colorObj.r;
        this.gStart = this.material.color.g = colorObj.g;
        this.gRange = colorEndObj.g - colorObj.g;
        this.bStart = this.material.color.b = colorObj.b;
        this.bRange = colorEndObj.b - colorObj.b;
        this.sprite.position.set(worldX, worldY, worldZ);
    }
    update() {
        const currentTime = Date.now() - this.startTime;
        if (currentTime > this.lifeTime) {
            this.dispose();
            return;
        }
        this.sprite.position.x += (this.speedX += this.accelX);
        this.sprite.position.y += (this.speedY += this.accelY);
        this.sprite.position.z += (this.speedZ += this.accelZ);
        const timeRatio = currentTime / this.lifeTime;
        const deltaScale = timeRatio * this.sizeRange;
        this.sprite.scale.x = this.sprite.scale.y = this.scaleStart + deltaScale;
        const deltaOpacity = timeRatio * this.opacityRange;
        this.material.opacity = this.opacityStart + deltaOpacity;
        const deltar = timeRatio * this.rRange;
        this.material.color.r = this.rStart + deltar;
        const deltag = timeRatio * this.gRange;
        this.material.color.g = this.gStart + deltag;
        const deltab = timeRatio * this.bRange;
        this.material.color.b = this.bStart + deltab;
    }
    dispose() {
        scene.remove(this.sprite);
        activeParticles.delete(this);
        disposed.push(this);
    }
}
