import { deg2Rad, rad2Deg } from "@lincode/math";
import { Reactive } from "@lincode/reactivity";
import { applyMixins, debounce } from "@lincode/utils";
import { PerspectiveCamera, Vector3 } from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { camFar, camNear, scaleDown, scaleUp } from "../../engine/constants";
import { container } from "../../engine/renderLoop/renderSetup";
import { getCamera } from "../../states/useCamera";
import CameraMixin from "../core/mixins/CameraMixin";
import { orbitCameraDefaults, orbitCameraSchema } from "../../interface/IOrbitCamera";
import { loop } from "../../engine/eventLoop";
import { vector3 } from "../utils/reusables";
import { MIN_POLAR_ANGLE, MAX_POLAR_ANGLE } from "../../globals";
import { getTransformControlsDragging } from "../../states/useTransformControlsDragging";
import { onKeyClear } from "../../events/onKeyClear";
import { onSceneChange } from "../../events/onSceneChange";
import PositionedItem from "../../api/core/PositionedItem";
import scene from "../../engine/scene";
class OrbitCamera extends PositionedItem {
    constructor(camera = new PerspectiveCamera(75, 1, camNear, camFar)) {
        super(camera);
        this.camera = camera;
        this.updateDebounced = debounce(() => this.controls.update(), 0, "trailing");
        this.targetState = new Reactive(undefined);
        this.enableZoomState = new Reactive(false);
        this.enableFlyState = new Reactive(false);
        this.enabledState = new Reactive(true);
        this._minPolarAngle = MIN_POLAR_ANGLE * deg2Rad;
        this._maxPolarAngle = MAX_POLAR_ANGLE * deg2Rad;
        this._minAzimuthAngle = -Infinity;
        this._maxAzimuthAngle = Infinity;
        scene.add(camera);
        this.initCamera();
        this.createEffect(() => {
            const target = this.targetState.get();
            if (!target)
                return;
            this.controls.target = target.outerObject3d.position;
            const handle = onSceneChange(() => target.parent !== this && this.targetState.set(undefined));
            return () => {
                this.controls.target = new Vector3();
                handle.cancel();
            };
        }, [this.targetState.get]);
        const controls = this.controls = new OrbitControls(camera, container);
        controls.enabled = false;
        controls.enablePan = false;
        controls.enableZoom = false;
        controls.minPolarAngle = this._minPolarAngle;
        controls.maxPolarAngle = this._maxPolarAngle;
        controls.minAzimuthAngle = this._minAzimuthAngle;
        controls.maxAzimuthAngle = this._maxAzimuthAngle;
        camera.position.z = 5;
        this.updateDebounced();
        this.createEffect(() => {
            if (getTransformControlsDragging() || getCamera() !== camera || !this.enabledState.get())
                return;
            controls.enabled = true;
            const handle = loop(this.updateDebounced);
            if (this.enableZoomState.get()) {
                const cb = (e) => {
                    e.preventDefault();
                    const direction = camera.getWorldDirection(vector3);
                    let pt = camera.position.clone().add(direction.clone().multiplyScalar(-e.deltaY * scaleDown));
                    const localPt = camera.worldToLocal(pt.clone());
                    const localTarget = camera.worldToLocal(controls.target.clone());
                    if (localPt.z - localTarget.z <= 1)
                        pt = controls.target.clone().add(direction.multiplyScalar(-1));
                    camera.position.copy(pt);
                    this.updateDebounced();
                };
                container.addEventListener("wheel", cb);
                handle.then(() => container.removeEventListener("wheel", cb));
            }
            if (this.enableFlyState.get()) {
                const downSet = new Set();
                const moveForward = (distance) => {
                    const direction = camera.getWorldDirection(vector3);
                    camera.position.add(direction.clone().multiplyScalar(distance * scaleDown));
                    this.controls.target.copy(camera.position).add(direction);
                    this.updateDebounced();
                };
                const moveRight = (distance) => {
                    vector3.setFromMatrixColumn(this.outerObject3d.matrix, 0);
                    camera.position.addScaledVector(vector3, distance * scaleDown);
                    this.controls.target.addScaledVector(vector3, distance * scaleDown);
                    this.updateDebounced();
                };
                const moveUp = (distance) => {
                    const dist = distance * scaleDown;
                    camera.position.y += dist;
                    this.controls.target.y += dist;
                    this.updateDebounced();
                };
                handle.watch(loop(() => {
                    if (downSet.has("w"))
                        moveForward(downSet.has("Shift") ? 50 : 10);
                    else if (downSet.has("s"))
                        moveForward(downSet.has("Shift") ? -50 : -10);
                    if (downSet.has("a"))
                        moveRight(-10);
                    else if (downSet.has("d"))
                        moveRight(10);
                    if (downSet.has("ArrowDown"))
                        moveUp(-10);
                    else if (downSet.has("ArrowUp"))
                        moveUp(10);
                }));
                const handleKeyDown = (e) => {
                    downSet.add(e.key.length === 1 ? e.key.toLocaleLowerCase() : e.key);
                };
                const handleKeyUp = (e) => {
                    downSet.delete(e.key.length === 1 ? e.key.toLowerCase() : e.key);
                };
                document.addEventListener("keydown", handleKeyDown);
                document.addEventListener("keyup", handleKeyUp);
                handle.watch(onKeyClear(() => downSet.clear()));
                handle.then(() => {
                    document.removeEventListener("keydown", handleKeyDown);
                    document.removeEventListener("keyup", handleKeyUp);
                });
            }
            return () => {
                controls.enabled = false;
                handle.cancel();
            };
        }, [getCamera, getTransformControlsDragging, this.enableZoomState.get, this.enableFlyState.get, this.enabledState.get]);
        this.then(() => controls.dispose());
    }
    get targetX() {
        var _a;
        return (_a = this._targetX) !== null && _a !== void 0 ? _a : (this._targetX = 0);
    }
    set targetX(val) {
        this._targetX = val;
        this.controls.target.x = val * scaleDown;
    }
    get targetY() {
        var _a;
        return (_a = this._targetY) !== null && _a !== void 0 ? _a : (this._targetY = 0);
    }
    set targetY(val) {
        this._targetY = val;
        this.controls.target.y = val * scaleDown;
    }
    get targetZ() {
        var _a;
        return (_a = this._targetZ) !== null && _a !== void 0 ? _a : (this._targetZ = 0);
    }
    set targetZ(val) {
        this._targetZ = val;
        this.controls.target.z = val * scaleDown;
    }
    append(object) {
        var _a;
        if (this.targetState.get()) {
            super.append(object);
            return;
        }
        this._append(object);
        (_a = this.outerObject3d.parent) === null || _a === void 0 ? void 0 : _a.add(object.outerObject3d);
        this.targetState.set(object);
    }
    attach(object) {
        var _a;
        if (this.targetState.get()) {
            super.attach(object);
            return;
        }
        this._append(object);
        (_a = this.outerObject3d.parent) === null || _a === void 0 ? void 0 : _a.attach(object.outerObject3d);
        this.targetState.set(object);
    }
    get x() {
        return this.camera.position.x * scaleUp;
    }
    set x(val) {
        this.camera.position.x = val * scaleDown;
    }
    get y() {
        return this.camera.position.y * scaleUp;
    }
    set y(val) {
        this.camera.position.y = val * scaleDown;
    }
    get z() {
        return this.camera.position.z * scaleUp;
    }
    set z(val) {
        this.camera.position.z = val * scaleDown;
    }
    get rotationX() {
        return this.camera.rotation.x * rad2Deg;
    }
    get rotationY() {
        return this.camera.rotation.y * rad2Deg;
    }
    get rotationZ() {
        return this.camera.rotation.z * rad2Deg;
    }
    get enableDamping() {
        return this.controls.enableDamping;
    }
    set enableDamping(val) {
        this.controls.enableDamping = val;
    }
    get enablePan() {
        return this.controls.enablePan;
    }
    set enablePan(val) {
        this.controls.enablePan = val;
    }
    get enableZoom() {
        return this.enableZoomState.get();
    }
    set enableZoom(val) {
        this.enableZoomState.set(val);
    }
    get enableFly() {
        return this.enableFlyState.get();
    }
    set enableFly(val) {
        this.enableFlyState.set(val);
    }
    get enabled() {
        return this.enabledState.get();
    }
    set enabled(val) {
        this.enabledState.set(val);
    }
    get autoRotate() {
        return this.controls.autoRotate;
    }
    set autoRotate(val) {
        this.controls.autoRotate = val;
    }
    get autoRotateSpeed() {
        return this.controls.autoRotateSpeed;
    }
    set autoRotateSpeed(val) {
        this.controls.autoRotateSpeed = val;
    }
    get minPolarAngle() {
        return this._minPolarAngle * rad2Deg;
    }
    set minPolarAngle(val) {
        this.controls.minPolarAngle = this._minPolarAngle = val * deg2Rad;
    }
    get maxPolarAngle() {
        return this._maxPolarAngle * rad2Deg;
    }
    set maxPolarAngle(val) {
        this.controls.maxPolarAngle = this._maxPolarAngle = val * deg2Rad;
    }
    get minAzimuthAngle() {
        return this._minAzimuthAngle * rad2Deg;
    }
    set minAzimuthAngle(val) {
        this.controls.minAzimuthAngle = this._minAzimuthAngle = val * deg2Rad;
    }
    get maxAzimuthAngle() {
        return this._maxAzimuthAngle * rad2Deg;
    }
    set maxAzimuthAngle(val) {
        this.controls.maxAzimuthAngle = this._maxAzimuthAngle = val * deg2Rad;
    }
    get azimuthAngle() {
        return this.controls.getAzimuthalAngle() * rad2Deg;
    }
    set azimuthAngle(val) {
        this.controls.minAzimuthAngle = this.controls.maxAzimuthAngle = val * deg2Rad;
        this.controls.update();
        this.queueMicrotask(() => {
            this.controls.minAzimuthAngle = this._minAzimuthAngle;
            this.controls.maxAzimuthAngle = this._maxAzimuthAngle;
        });
    }
    get polarAngle() {
        return this.controls.getPolarAngle() * rad2Deg;
    }
    set polarAngle(val) {
        this.controls.minPolarAngle = this.controls.maxPolarAngle = val * deg2Rad;
        this.controls.update();
        this.queueMicrotask(() => {
            this.controls.minPolarAngle = this._minPolarAngle;
            this.controls.maxPolarAngle = this._maxPolarAngle;
        });
    }
    get distance() {
        return this.controls.getDistance() * scaleUp;
    }
    set distance(val) {
        this.controls.minDistance = this.controls.maxDistance = val * scaleDown;
        this.controls.update();
        this.queueMicrotask(() => {
            this.controls.minDistance = -Infinity;
            this.controls.maxDistance = Infinity;
        });
    }
    getCenter() {
        return this.getWorldPosition();
    }
}
OrbitCamera.componentName = "orbitCamera";
OrbitCamera.defaults = orbitCameraDefaults;
OrbitCamera.schema = orbitCameraSchema;
applyMixins(OrbitCamera, [CameraMixin]);
export default OrbitCamera;
